import 'well-known-symbols/Symbol.asyncIterator/auto';
import 'well-known-symbols/Symbol.iterator/auto';
import './polyfills/MediaRecorderShim';
import 'react-native-quick-base64';
import { registerGlobals as webrtcRegisterGlobals } from '@livekit/react-native-webrtc';
import { setupURLPolyfill } from 'react-native-url-polyfill';
import './polyfills/EncoderDecoderTogether.min.js';
import AudioSession, { AndroidAudioTypePresets, getDefaultAppleAudioConfigurationForMode } from './audio/AudioSession';
import { PixelRatio, Platform } from 'react-native';
import RNE2EEManager from './e2ee/RNE2EEManager';
import RNKeyProvider from './e2ee/RNKeyProvider';
import { setupNativeEvents } from './events/EventEmitter';
import { ReadableStream, WritableStream } from 'web-streams-polyfill';

/**
 * Registers the required globals needed for LiveKit to work.
 *
 * Must be called before using LiveKit.
 */
export function registerGlobals() {
  webrtcRegisterGlobals();
  iosCategoryEnforce();
  livekitRegisterGlobals();
  setupURLPolyfill();
  fixWebrtcAdapter();
  shimPromiseAllSettled();
  shimArrayAt();
  shimCryptoUuid();
  shimWebstreams();
  setupNativeEvents();
}

/**
 * Enforces changing to playAndRecord category prior to obtaining microphone.
 */
function iosCategoryEnforce() {
  if (Platform.OS === 'ios') {
    // @ts-ignore
    let getUserMediaFunc = global.navigator.mediaDevices.getUserMedia;
    // @ts-ignore
    global.navigator.mediaDevices.getUserMedia = async constraints => {
      if (constraints.audio) {
        await AudioSession.setAppleAudioConfiguration({
          audioCategory: 'playAndRecord'
        });
      }
      return await getUserMediaFunc(constraints);
    };
  }
}
function livekitRegisterGlobals() {
  let lkGlobal = {
    platform: Platform.OS,
    devicePixelRatio: PixelRatio.get()
  };

  // @ts-ignore
  global.LiveKitReactNativeGlobal = lkGlobal;
}
function fixWebrtcAdapter() {
  var _window;
  // @ts-ignore
  if (((_window = window) === null || _window === void 0 ? void 0 : _window.navigator) !== undefined) {
    // @ts-ignore
    const {
      navigator
    } = window;
    if (navigator.userAgent === undefined) {
      navigator.userAgent = navigator.product ?? 'Unknown';
    }
  }
}
function shimPromiseAllSettled() {
  var allSettled = require('promise.allsettled');
  allSettled.shim();
}
function shimArrayAt() {
  // Some versions of RN don't have Array.prototype.at, which is used by sdp-transform
  if (!Array.prototype.at) {
    var at = require('array.prototype.at');
    at.shim();
  }
}
function shimCryptoUuid() {
  var _global$crypto;
  let crypto = global.crypto;
  if (typeof ((_global$crypto = global.crypto) === null || _global$crypto === void 0 ? void 0 : _global$crypto.randomUUID) !== 'function') {
    let createRandomUUID = () => {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        /* eslint-disable no-bitwise */
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    };
    if (!crypto) {
      crypto = {};
      global.crypto = crypto;
    }
    crypto.randomUUID = createRandomUUID;
  }
}
function shimWebstreams() {
  // @ts-expect-error: global.WritableStream isn't typed here.
  if (typeof global.WritableStream === 'undefined') {
    // @ts-expect-error
    global.WritableStream = WritableStream;
  }

  // @ts-expect-error: global.ReadableStream isn't typed here.
  if (typeof global.ReadableStream === 'undefined') {
    // @ts-expect-error
    global.ReadableStream = ReadableStream;
  }
}
export * from './hooks';
export * from './components/BarVisualizer';
export * from './components/LiveKitRoom';
export * from './components/VideoTrack';
export * from './components/VideoView'; // deprecated
export * from './useParticipant'; // deprecated
export * from './useRoom'; // deprecated
export * from './logger';
export * from './audio/AudioManager';
export { AudioSession, RNE2EEManager, RNKeyProvider, AndroidAudioTypePresets, getDefaultAppleAudioConfigurationForMode };
//# sourceMappingURL=index.js.map