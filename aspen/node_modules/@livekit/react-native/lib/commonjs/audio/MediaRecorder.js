"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MediaRecorder = void 0;
var _EventEmitter = require("../events/EventEmitter");
var _index = require("event-target-shim/index");
var _reactNativeQuickBase = require("react-native-quick-base64");
var _LKNativeModule = _interopRequireDefault(require("../LKNativeModule"));
var _logger = require("../logger");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// typeof MediaRecorder
// const Tester = (stream: MediaStream) => {
//   return new AudioRecorder(stream) satisfies MediaRecorder;
// };

/**
 * A MediaRecord implementation only meant for recording audio streams.
 *
 * @private
 */
class MediaRecorder extends _index.EventTarget {
  constructor(stream) {
    super();
    _defineProperty(this, "mimeType", 'audio/pcm');
    _defineProperty(this, "audioBitsPerSecond", 0);
    // TODO?
    _defineProperty(this, "state", 'inactive');
    _defineProperty(this, "stream", void 0);
    _defineProperty(this, "videoBitsPerSecond", 0);
    // TODO?
    _defineProperty(this, "audioBitrateMode", 'constant');
    _defineProperty(this, "_reactTag", undefined);
    _defineProperty(this, "_parts", []);
    this.stream = stream;
  }
  registerListener() {
    let audioTracks = this.stream.getAudioTracks();
    if (audioTracks.length !== 1) {
      return;
    }
    const mediaStreamTrack = audioTracks[0];
    const peerConnectionId = mediaStreamTrack._peerConnectionId ?? -1;
    const mediaStreamTrackId = mediaStreamTrack === null || mediaStreamTrack === void 0 ? void 0 : mediaStreamTrack.id;
    this._reactTag = _LKNativeModule.default.createAudioSinkListener(peerConnectionId, mediaStreamTrackId);
    (0, _EventEmitter.addListener)(this, 'LK_AUDIO_DATA', event => {
      if (this._reactTag && event.id === this._reactTag && this.state === 'recording') {
        let str = event.data;
        this._parts.push(str);
      }
    });
  }
  unregisterListener() {
    if (this._reactTag) {
      let audioTracks = this.stream.getAudioTracks();
      if (audioTracks.length !== 1) {
        _logger.log.error("couldn't find any audio tracks to record from!");
        return;
      }
      const mediaStreamTrack = audioTracks[0];
      const peerConnectionId = mediaStreamTrack._peerConnectionId ?? -1;
      const mediaStreamTrackId = mediaStreamTrack === null || mediaStreamTrack === void 0 ? void 0 : mediaStreamTrack.id;
      _LKNativeModule.default.deleteAudioSinkListener(this._reactTag, peerConnectionId, mediaStreamTrackId);
    }
  }
  pause() {
    this.state = 'paused';
    this.dispatchEvent(new _index.Event('pause'));
  }
  resume() {
    this.state = 'recording';
    this.dispatchEvent(new _index.Event('resume'));
  }
  start() {
    this.registerListener();
    this.state = 'recording';
    this.dispatchEvent(new _index.Event('start'));
  }
  stop() {
    // dispatch data must come before stopping.
    this.dispatchData();
    this.unregisterListener();
    this.state = 'inactive';
    this.dispatchEvent(new _index.Event('stop'));
  }
  requestData() {
    this.dispatchData();
  }
  dispatchData() {
    let combinedStr = this._parts.reduce((sum, cur) => sum + cur, '');
    let data = (0, _reactNativeQuickBase.toByteArray)(combinedStr);
    this._parts = [];
    this.dispatchEvent(new BlobEvent('dataavailable', {
      data: {
        byteArray: data
      }
    }));
  }
}

/**
 * @eventClass
 * This event is fired whenever the Track is changed in PeerConnection.
 * @param {TRACK_EVENTS} type - The type of event.
 * @param {IRTCTrackEventInitDict} eventInitDict - The event init properties.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/track_event MDN} for details.
 */
exports.MediaRecorder = MediaRecorder;
class BlobEvent extends _index.Event {
  constructor(type, eventInitDict) {
    super(type, eventInitDict);
    /** @eventProperty */
    _defineProperty(this, "data", void 0);
    this.data = eventInitDict.data;
  }
}

/**
 * Define the `onxxx` event handlers.
 */
const proto = MediaRecorder.prototype;
(0, _index.defineEventAttribute)(proto, 'dataavailable');
(0, _index.defineEventAttribute)(proto, 'error');
(0, _index.defineEventAttribute)(proto, 'pause');
(0, _index.defineEventAttribute)(proto, 'resume');
(0, _index.defineEventAttribute)(proto, 'start');
(0, _index.defineEventAttribute)(proto, 'stop');
//# sourceMappingURL=MediaRecorder.js.map